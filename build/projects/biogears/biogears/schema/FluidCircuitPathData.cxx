// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
#include "Properties.hxx"

//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "FluidCircuitPathData.hxx"

#include "ScalarFlowResistanceData.hxx"

#include "ScalarFlowComplianceData.hxx"

#include "ScalarFlowInertanceData.hxx"

#include "ScalarVolumePerTimeData.hxx"

#include "ScalarPressureData.hxx"

namespace mil
{
  namespace tatrc
  {
    namespace physiology
    {
      namespace datamodel
      {
        // FluidCircuitPathData
        // 

        const FluidCircuitPathData::Resistance_optional& FluidCircuitPathData::
        Resistance () const
        {
          return this->Resistance_;
        }

        FluidCircuitPathData::Resistance_optional& FluidCircuitPathData::
        Resistance ()
        {
          return this->Resistance_;
        }

        void FluidCircuitPathData::
        Resistance (const Resistance_type& x)
        {
          this->Resistance_.set (x);
        }

        void FluidCircuitPathData::
        Resistance (const Resistance_optional& x)
        {
          this->Resistance_ = x;
        }

        void FluidCircuitPathData::
        Resistance (::std::unique_ptr< Resistance_type > x)
        {
          this->Resistance_.set (std::move (x));
        }

        const FluidCircuitPathData::NextResistance_optional& FluidCircuitPathData::
        NextResistance () const
        {
          return this->NextResistance_;
        }

        FluidCircuitPathData::NextResistance_optional& FluidCircuitPathData::
        NextResistance ()
        {
          return this->NextResistance_;
        }

        void FluidCircuitPathData::
        NextResistance (const NextResistance_type& x)
        {
          this->NextResistance_.set (x);
        }

        void FluidCircuitPathData::
        NextResistance (const NextResistance_optional& x)
        {
          this->NextResistance_ = x;
        }

        void FluidCircuitPathData::
        NextResistance (::std::unique_ptr< NextResistance_type > x)
        {
          this->NextResistance_.set (std::move (x));
        }

        const FluidCircuitPathData::ResistanceBaseline_optional& FluidCircuitPathData::
        ResistanceBaseline () const
        {
          return this->ResistanceBaseline_;
        }

        FluidCircuitPathData::ResistanceBaseline_optional& FluidCircuitPathData::
        ResistanceBaseline ()
        {
          return this->ResistanceBaseline_;
        }

        void FluidCircuitPathData::
        ResistanceBaseline (const ResistanceBaseline_type& x)
        {
          this->ResistanceBaseline_.set (x);
        }

        void FluidCircuitPathData::
        ResistanceBaseline (const ResistanceBaseline_optional& x)
        {
          this->ResistanceBaseline_ = x;
        }

        void FluidCircuitPathData::
        ResistanceBaseline (::std::unique_ptr< ResistanceBaseline_type > x)
        {
          this->ResistanceBaseline_.set (std::move (x));
        }

        const FluidCircuitPathData::Compliance_optional& FluidCircuitPathData::
        Compliance () const
        {
          return this->Compliance_;
        }

        FluidCircuitPathData::Compliance_optional& FluidCircuitPathData::
        Compliance ()
        {
          return this->Compliance_;
        }

        void FluidCircuitPathData::
        Compliance (const Compliance_type& x)
        {
          this->Compliance_.set (x);
        }

        void FluidCircuitPathData::
        Compliance (const Compliance_optional& x)
        {
          this->Compliance_ = x;
        }

        void FluidCircuitPathData::
        Compliance (::std::unique_ptr< Compliance_type > x)
        {
          this->Compliance_.set (std::move (x));
        }

        const FluidCircuitPathData::NextCompliance_optional& FluidCircuitPathData::
        NextCompliance () const
        {
          return this->NextCompliance_;
        }

        FluidCircuitPathData::NextCompliance_optional& FluidCircuitPathData::
        NextCompliance ()
        {
          return this->NextCompliance_;
        }

        void FluidCircuitPathData::
        NextCompliance (const NextCompliance_type& x)
        {
          this->NextCompliance_.set (x);
        }

        void FluidCircuitPathData::
        NextCompliance (const NextCompliance_optional& x)
        {
          this->NextCompliance_ = x;
        }

        void FluidCircuitPathData::
        NextCompliance (::std::unique_ptr< NextCompliance_type > x)
        {
          this->NextCompliance_.set (std::move (x));
        }

        const FluidCircuitPathData::ComplianceBaseline_optional& FluidCircuitPathData::
        ComplianceBaseline () const
        {
          return this->ComplianceBaseline_;
        }

        FluidCircuitPathData::ComplianceBaseline_optional& FluidCircuitPathData::
        ComplianceBaseline ()
        {
          return this->ComplianceBaseline_;
        }

        void FluidCircuitPathData::
        ComplianceBaseline (const ComplianceBaseline_type& x)
        {
          this->ComplianceBaseline_.set (x);
        }

        void FluidCircuitPathData::
        ComplianceBaseline (const ComplianceBaseline_optional& x)
        {
          this->ComplianceBaseline_ = x;
        }

        void FluidCircuitPathData::
        ComplianceBaseline (::std::unique_ptr< ComplianceBaseline_type > x)
        {
          this->ComplianceBaseline_.set (std::move (x));
        }

        const FluidCircuitPathData::Inertance_optional& FluidCircuitPathData::
        Inertance () const
        {
          return this->Inertance_;
        }

        FluidCircuitPathData::Inertance_optional& FluidCircuitPathData::
        Inertance ()
        {
          return this->Inertance_;
        }

        void FluidCircuitPathData::
        Inertance (const Inertance_type& x)
        {
          this->Inertance_.set (x);
        }

        void FluidCircuitPathData::
        Inertance (const Inertance_optional& x)
        {
          this->Inertance_ = x;
        }

        void FluidCircuitPathData::
        Inertance (::std::unique_ptr< Inertance_type > x)
        {
          this->Inertance_.set (std::move (x));
        }

        const FluidCircuitPathData::NextInertance_optional& FluidCircuitPathData::
        NextInertance () const
        {
          return this->NextInertance_;
        }

        FluidCircuitPathData::NextInertance_optional& FluidCircuitPathData::
        NextInertance ()
        {
          return this->NextInertance_;
        }

        void FluidCircuitPathData::
        NextInertance (const NextInertance_type& x)
        {
          this->NextInertance_.set (x);
        }

        void FluidCircuitPathData::
        NextInertance (const NextInertance_optional& x)
        {
          this->NextInertance_ = x;
        }

        void FluidCircuitPathData::
        NextInertance (::std::unique_ptr< NextInertance_type > x)
        {
          this->NextInertance_.set (std::move (x));
        }

        const FluidCircuitPathData::InertanceBaseline_optional& FluidCircuitPathData::
        InertanceBaseline () const
        {
          return this->InertanceBaseline_;
        }

        FluidCircuitPathData::InertanceBaseline_optional& FluidCircuitPathData::
        InertanceBaseline ()
        {
          return this->InertanceBaseline_;
        }

        void FluidCircuitPathData::
        InertanceBaseline (const InertanceBaseline_type& x)
        {
          this->InertanceBaseline_.set (x);
        }

        void FluidCircuitPathData::
        InertanceBaseline (const InertanceBaseline_optional& x)
        {
          this->InertanceBaseline_ = x;
        }

        void FluidCircuitPathData::
        InertanceBaseline (::std::unique_ptr< InertanceBaseline_type > x)
        {
          this->InertanceBaseline_.set (std::move (x));
        }

        const FluidCircuitPathData::Flow_optional& FluidCircuitPathData::
        Flow () const
        {
          return this->Flow_;
        }

        FluidCircuitPathData::Flow_optional& FluidCircuitPathData::
        Flow ()
        {
          return this->Flow_;
        }

        void FluidCircuitPathData::
        Flow (const Flow_type& x)
        {
          this->Flow_.set (x);
        }

        void FluidCircuitPathData::
        Flow (const Flow_optional& x)
        {
          this->Flow_ = x;
        }

        void FluidCircuitPathData::
        Flow (::std::unique_ptr< Flow_type > x)
        {
          this->Flow_.set (std::move (x));
        }

        const FluidCircuitPathData::NextFlow_optional& FluidCircuitPathData::
        NextFlow () const
        {
          return this->NextFlow_;
        }

        FluidCircuitPathData::NextFlow_optional& FluidCircuitPathData::
        NextFlow ()
        {
          return this->NextFlow_;
        }

        void FluidCircuitPathData::
        NextFlow (const NextFlow_type& x)
        {
          this->NextFlow_.set (x);
        }

        void FluidCircuitPathData::
        NextFlow (const NextFlow_optional& x)
        {
          this->NextFlow_ = x;
        }

        void FluidCircuitPathData::
        NextFlow (::std::unique_ptr< NextFlow_type > x)
        {
          this->NextFlow_.set (std::move (x));
        }

        const FluidCircuitPathData::FlowSource_optional& FluidCircuitPathData::
        FlowSource () const
        {
          return this->FlowSource_;
        }

        FluidCircuitPathData::FlowSource_optional& FluidCircuitPathData::
        FlowSource ()
        {
          return this->FlowSource_;
        }

        void FluidCircuitPathData::
        FlowSource (const FlowSource_type& x)
        {
          this->FlowSource_.set (x);
        }

        void FluidCircuitPathData::
        FlowSource (const FlowSource_optional& x)
        {
          this->FlowSource_ = x;
        }

        void FluidCircuitPathData::
        FlowSource (::std::unique_ptr< FlowSource_type > x)
        {
          this->FlowSource_.set (std::move (x));
        }

        const FluidCircuitPathData::NextFlowSource_optional& FluidCircuitPathData::
        NextFlowSource () const
        {
          return this->NextFlowSource_;
        }

        FluidCircuitPathData::NextFlowSource_optional& FluidCircuitPathData::
        NextFlowSource ()
        {
          return this->NextFlowSource_;
        }

        void FluidCircuitPathData::
        NextFlowSource (const NextFlowSource_type& x)
        {
          this->NextFlowSource_.set (x);
        }

        void FluidCircuitPathData::
        NextFlowSource (const NextFlowSource_optional& x)
        {
          this->NextFlowSource_ = x;
        }

        void FluidCircuitPathData::
        NextFlowSource (::std::unique_ptr< NextFlowSource_type > x)
        {
          this->NextFlowSource_.set (std::move (x));
        }

        const FluidCircuitPathData::FlowSourceBaseline_optional& FluidCircuitPathData::
        FlowSourceBaseline () const
        {
          return this->FlowSourceBaseline_;
        }

        FluidCircuitPathData::FlowSourceBaseline_optional& FluidCircuitPathData::
        FlowSourceBaseline ()
        {
          return this->FlowSourceBaseline_;
        }

        void FluidCircuitPathData::
        FlowSourceBaseline (const FlowSourceBaseline_type& x)
        {
          this->FlowSourceBaseline_.set (x);
        }

        void FluidCircuitPathData::
        FlowSourceBaseline (const FlowSourceBaseline_optional& x)
        {
          this->FlowSourceBaseline_ = x;
        }

        void FluidCircuitPathData::
        FlowSourceBaseline (::std::unique_ptr< FlowSourceBaseline_type > x)
        {
          this->FlowSourceBaseline_.set (std::move (x));
        }

        const FluidCircuitPathData::PressureSource_optional& FluidCircuitPathData::
        PressureSource () const
        {
          return this->PressureSource_;
        }

        FluidCircuitPathData::PressureSource_optional& FluidCircuitPathData::
        PressureSource ()
        {
          return this->PressureSource_;
        }

        void FluidCircuitPathData::
        PressureSource (const PressureSource_type& x)
        {
          this->PressureSource_.set (x);
        }

        void FluidCircuitPathData::
        PressureSource (const PressureSource_optional& x)
        {
          this->PressureSource_ = x;
        }

        void FluidCircuitPathData::
        PressureSource (::std::unique_ptr< PressureSource_type > x)
        {
          this->PressureSource_.set (std::move (x));
        }

        const FluidCircuitPathData::NextPressureSource_optional& FluidCircuitPathData::
        NextPressureSource () const
        {
          return this->NextPressureSource_;
        }

        FluidCircuitPathData::NextPressureSource_optional& FluidCircuitPathData::
        NextPressureSource ()
        {
          return this->NextPressureSource_;
        }

        void FluidCircuitPathData::
        NextPressureSource (const NextPressureSource_type& x)
        {
          this->NextPressureSource_.set (x);
        }

        void FluidCircuitPathData::
        NextPressureSource (const NextPressureSource_optional& x)
        {
          this->NextPressureSource_ = x;
        }

        void FluidCircuitPathData::
        NextPressureSource (::std::unique_ptr< NextPressureSource_type > x)
        {
          this->NextPressureSource_.set (std::move (x));
        }

        const FluidCircuitPathData::PressureSourceBaseline_optional& FluidCircuitPathData::
        PressureSourceBaseline () const
        {
          return this->PressureSourceBaseline_;
        }

        FluidCircuitPathData::PressureSourceBaseline_optional& FluidCircuitPathData::
        PressureSourceBaseline ()
        {
          return this->PressureSourceBaseline_;
        }

        void FluidCircuitPathData::
        PressureSourceBaseline (const PressureSourceBaseline_type& x)
        {
          this->PressureSourceBaseline_.set (x);
        }

        void FluidCircuitPathData::
        PressureSourceBaseline (const PressureSourceBaseline_optional& x)
        {
          this->PressureSourceBaseline_ = x;
        }

        void FluidCircuitPathData::
        PressureSourceBaseline (::std::unique_ptr< PressureSourceBaseline_type > x)
        {
          this->PressureSourceBaseline_.set (std::move (x));
        }

        const FluidCircuitPathData::ValveBreakdownPressure_optional& FluidCircuitPathData::
        ValveBreakdownPressure () const
        {
          return this->ValveBreakdownPressure_;
        }

        FluidCircuitPathData::ValveBreakdownPressure_optional& FluidCircuitPathData::
        ValveBreakdownPressure ()
        {
          return this->ValveBreakdownPressure_;
        }

        void FluidCircuitPathData::
        ValveBreakdownPressure (const ValveBreakdownPressure_type& x)
        {
          this->ValveBreakdownPressure_.set (x);
        }

        void FluidCircuitPathData::
        ValveBreakdownPressure (const ValveBreakdownPressure_optional& x)
        {
          this->ValveBreakdownPressure_ = x;
        }

        void FluidCircuitPathData::
        ValveBreakdownPressure (::std::unique_ptr< ValveBreakdownPressure_type > x)
        {
          this->ValveBreakdownPressure_.set (std::move (x));
        }
      }
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace mil
{
  namespace tatrc
  {
    namespace physiology
    {
      namespace datamodel
      {
        // FluidCircuitPathData
        //

        FluidCircuitPathData::
        FluidCircuitPathData ()
        : ::mil::tatrc::physiology::datamodel::CircuitPathData (),
          Resistance_ (this),
          NextResistance_ (this),
          ResistanceBaseline_ (this),
          Compliance_ (this),
          NextCompliance_ (this),
          ComplianceBaseline_ (this),
          Inertance_ (this),
          NextInertance_ (this),
          InertanceBaseline_ (this),
          Flow_ (this),
          NextFlow_ (this),
          FlowSource_ (this),
          NextFlowSource_ (this),
          FlowSourceBaseline_ (this),
          PressureSource_ (this),
          NextPressureSource_ (this),
          PressureSourceBaseline_ (this),
          ValveBreakdownPressure_ (this)
        {
        }

        FluidCircuitPathData::
        FluidCircuitPathData (const Name_type& Name,
                              const SourceNode_type& SourceNode,
                              const TargetNode_type& TargetNode)
        : ::mil::tatrc::physiology::datamodel::CircuitPathData (Name,
                                                                SourceNode,
                                                                TargetNode),
          Resistance_ (this),
          NextResistance_ (this),
          ResistanceBaseline_ (this),
          Compliance_ (this),
          NextCompliance_ (this),
          ComplianceBaseline_ (this),
          Inertance_ (this),
          NextInertance_ (this),
          InertanceBaseline_ (this),
          Flow_ (this),
          NextFlow_ (this),
          FlowSource_ (this),
          NextFlowSource_ (this),
          FlowSourceBaseline_ (this),
          PressureSource_ (this),
          NextPressureSource_ (this),
          PressureSourceBaseline_ (this),
          ValveBreakdownPressure_ (this)
        {
        }

        FluidCircuitPathData::
        FluidCircuitPathData (::std::unique_ptr< Name_type > Name,
                              ::std::unique_ptr< SourceNode_type > SourceNode,
                              ::std::unique_ptr< TargetNode_type > TargetNode)
        : ::mil::tatrc::physiology::datamodel::CircuitPathData (std::move (Name),
                                                                std::move (SourceNode),
                                                                std::move (TargetNode)),
          Resistance_ (this),
          NextResistance_ (this),
          ResistanceBaseline_ (this),
          Compliance_ (this),
          NextCompliance_ (this),
          ComplianceBaseline_ (this),
          Inertance_ (this),
          NextInertance_ (this),
          InertanceBaseline_ (this),
          Flow_ (this),
          NextFlow_ (this),
          FlowSource_ (this),
          NextFlowSource_ (this),
          FlowSourceBaseline_ (this),
          PressureSource_ (this),
          NextPressureSource_ (this),
          PressureSourceBaseline_ (this),
          ValveBreakdownPressure_ (this)
        {
        }

        FluidCircuitPathData::
        FluidCircuitPathData (const FluidCircuitPathData& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::CircuitPathData (x, f, c),
          Resistance_ (x.Resistance_, f, this),
          NextResistance_ (x.NextResistance_, f, this),
          ResistanceBaseline_ (x.ResistanceBaseline_, f, this),
          Compliance_ (x.Compliance_, f, this),
          NextCompliance_ (x.NextCompliance_, f, this),
          ComplianceBaseline_ (x.ComplianceBaseline_, f, this),
          Inertance_ (x.Inertance_, f, this),
          NextInertance_ (x.NextInertance_, f, this),
          InertanceBaseline_ (x.InertanceBaseline_, f, this),
          Flow_ (x.Flow_, f, this),
          NextFlow_ (x.NextFlow_, f, this),
          FlowSource_ (x.FlowSource_, f, this),
          NextFlowSource_ (x.NextFlowSource_, f, this),
          FlowSourceBaseline_ (x.FlowSourceBaseline_, f, this),
          PressureSource_ (x.PressureSource_, f, this),
          NextPressureSource_ (x.NextPressureSource_, f, this),
          PressureSourceBaseline_ (x.PressureSourceBaseline_, f, this),
          ValveBreakdownPressure_ (x.ValveBreakdownPressure_, f, this)
        {
        }

        FluidCircuitPathData::
        FluidCircuitPathData (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::CircuitPathData (e, f | ::xml_schema::flags::base, c),
          Resistance_ (this),
          NextResistance_ (this),
          ResistanceBaseline_ (this),
          Compliance_ (this),
          NextCompliance_ (this),
          ComplianceBaseline_ (this),
          Inertance_ (this),
          NextInertance_ (this),
          InertanceBaseline_ (this),
          Flow_ (this),
          NextFlow_ (this),
          FlowSource_ (this),
          NextFlowSource_ (this),
          FlowSourceBaseline_ (this),
          PressureSource_ (this),
          NextPressureSource_ (this),
          PressureSourceBaseline_ (this),
          ValveBreakdownPressure_ (this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
            this->parse (p, f);
          }
        }

        void FluidCircuitPathData::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::mil::tatrc::physiology::datamodel::CircuitPathData::parse (p, f);

          for (; p.more_content (); p.next_content (false))
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // Resistance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Resistance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Resistance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Resistance_)
                {
                  ::std::unique_ptr< Resistance_type > r (
                    dynamic_cast< Resistance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Resistance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextResistance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextResistance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextResistance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextResistance_)
                {
                  ::std::unique_ptr< NextResistance_type > r (
                    dynamic_cast< NextResistance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextResistance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // ResistanceBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ResistanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ResistanceBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->ResistanceBaseline_)
                {
                  ::std::unique_ptr< ResistanceBaseline_type > r (
                    dynamic_cast< ResistanceBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->ResistanceBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // Compliance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Compliance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Compliance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Compliance_)
                {
                  ::std::unique_ptr< Compliance_type > r (
                    dynamic_cast< Compliance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Compliance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextCompliance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextCompliance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextCompliance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextCompliance_)
                {
                  ::std::unique_ptr< NextCompliance_type > r (
                    dynamic_cast< NextCompliance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextCompliance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // ComplianceBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ComplianceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ComplianceBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->ComplianceBaseline_)
                {
                  ::std::unique_ptr< ComplianceBaseline_type > r (
                    dynamic_cast< ComplianceBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->ComplianceBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // Inertance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Inertance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Inertance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Inertance_)
                {
                  ::std::unique_ptr< Inertance_type > r (
                    dynamic_cast< Inertance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Inertance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextInertance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextInertance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextInertance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextInertance_)
                {
                  ::std::unique_ptr< NextInertance_type > r (
                    dynamic_cast< NextInertance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextInertance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // InertanceBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "InertanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< InertanceBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->InertanceBaseline_)
                {
                  ::std::unique_ptr< InertanceBaseline_type > r (
                    dynamic_cast< InertanceBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->InertanceBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // Flow
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Flow",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Flow_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Flow_)
                {
                  ::std::unique_ptr< Flow_type > r (
                    dynamic_cast< Flow_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Flow_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextFlow
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextFlow",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextFlow_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextFlow_)
                {
                  ::std::unique_ptr< NextFlow_type > r (
                    dynamic_cast< NextFlow_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextFlow_.set (::std::move (r));
                  continue;
                }
              }
            }

            // FlowSource
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "FlowSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< FlowSource_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->FlowSource_)
                {
                  ::std::unique_ptr< FlowSource_type > r (
                    dynamic_cast< FlowSource_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->FlowSource_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextFlowSource
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextFlowSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextFlowSource_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextFlowSource_)
                {
                  ::std::unique_ptr< NextFlowSource_type > r (
                    dynamic_cast< NextFlowSource_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextFlowSource_.set (::std::move (r));
                  continue;
                }
              }
            }

            // FlowSourceBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "FlowSourceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< FlowSourceBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->FlowSourceBaseline_)
                {
                  ::std::unique_ptr< FlowSourceBaseline_type > r (
                    dynamic_cast< FlowSourceBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->FlowSourceBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // PressureSource
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "PressureSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< PressureSource_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->PressureSource_)
                {
                  ::std::unique_ptr< PressureSource_type > r (
                    dynamic_cast< PressureSource_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->PressureSource_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextPressureSource
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextPressureSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextPressureSource_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextPressureSource_)
                {
                  ::std::unique_ptr< NextPressureSource_type > r (
                    dynamic_cast< NextPressureSource_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextPressureSource_.set (::std::move (r));
                  continue;
                }
              }
            }

            // PressureSourceBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "PressureSourceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< PressureSourceBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->PressureSourceBaseline_)
                {
                  ::std::unique_ptr< PressureSourceBaseline_type > r (
                    dynamic_cast< PressureSourceBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->PressureSourceBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // ValveBreakdownPressure
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ValveBreakdownPressure",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ValveBreakdownPressure_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->ValveBreakdownPressure_)
                {
                  ::std::unique_ptr< ValveBreakdownPressure_type > r (
                    dynamic_cast< ValveBreakdownPressure_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->ValveBreakdownPressure_.set (::std::move (r));
                  continue;
                }
              }
            }

            break;
          }
        }

        FluidCircuitPathData* FluidCircuitPathData::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class FluidCircuitPathData (*this, f, c);
        }

        FluidCircuitPathData& FluidCircuitPathData::
        operator= (const FluidCircuitPathData& x)
        {
          if (this != &x)
          {
            static_cast< ::mil::tatrc::physiology::datamodel::CircuitPathData& > (*this) = x;
            this->Resistance_ = x.Resistance_;
            this->NextResistance_ = x.NextResistance_;
            this->ResistanceBaseline_ = x.ResistanceBaseline_;
            this->Compliance_ = x.Compliance_;
            this->NextCompliance_ = x.NextCompliance_;
            this->ComplianceBaseline_ = x.ComplianceBaseline_;
            this->Inertance_ = x.Inertance_;
            this->NextInertance_ = x.NextInertance_;
            this->InertanceBaseline_ = x.InertanceBaseline_;
            this->Flow_ = x.Flow_;
            this->NextFlow_ = x.NextFlow_;
            this->FlowSource_ = x.FlowSource_;
            this->NextFlowSource_ = x.NextFlowSource_;
            this->FlowSourceBaseline_ = x.FlowSourceBaseline_;
            this->PressureSource_ = x.PressureSource_;
            this->NextPressureSource_ = x.NextPressureSource_;
            this->PressureSourceBaseline_ = x.PressureSourceBaseline_;
            this->ValveBreakdownPressure_ = x.ValveBreakdownPressure_;
          }

          return *this;
        }

        FluidCircuitPathData::
        ~FluidCircuitPathData ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, FluidCircuitPathData >
        _xsd_FluidCircuitPathData_type_factory_init (
          "FluidCircuitPathData",
          "uri:/mil/tatrc/physiology/datamodel");
      }
    }
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace mil
{
  namespace tatrc
  {
    namespace physiology
    {
      namespace datamodel
      {
        ::std::ostream&
        operator<< (::std::ostream& o, const FluidCircuitPathData& i)
        {
          o << static_cast< const ::mil::tatrc::physiology::datamodel::CircuitPathData& > (i);

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Resistance ())
            {
              o << ::std::endl << "Resistance: ";
              om.insert (o, *i.Resistance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextResistance ())
            {
              o << ::std::endl << "NextResistance: ";
              om.insert (o, *i.NextResistance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.ResistanceBaseline ())
            {
              o << ::std::endl << "ResistanceBaseline: ";
              om.insert (o, *i.ResistanceBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Compliance ())
            {
              o << ::std::endl << "Compliance: ";
              om.insert (o, *i.Compliance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextCompliance ())
            {
              o << ::std::endl << "NextCompliance: ";
              om.insert (o, *i.NextCompliance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.ComplianceBaseline ())
            {
              o << ::std::endl << "ComplianceBaseline: ";
              om.insert (o, *i.ComplianceBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Inertance ())
            {
              o << ::std::endl << "Inertance: ";
              om.insert (o, *i.Inertance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextInertance ())
            {
              o << ::std::endl << "NextInertance: ";
              om.insert (o, *i.NextInertance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.InertanceBaseline ())
            {
              o << ::std::endl << "InertanceBaseline: ";
              om.insert (o, *i.InertanceBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Flow ())
            {
              o << ::std::endl << "Flow: ";
              om.insert (o, *i.Flow ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextFlow ())
            {
              o << ::std::endl << "NextFlow: ";
              om.insert (o, *i.NextFlow ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.FlowSource ())
            {
              o << ::std::endl << "FlowSource: ";
              om.insert (o, *i.FlowSource ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextFlowSource ())
            {
              o << ::std::endl << "NextFlowSource: ";
              om.insert (o, *i.NextFlowSource ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.FlowSourceBaseline ())
            {
              o << ::std::endl << "FlowSourceBaseline: ";
              om.insert (o, *i.FlowSourceBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.PressureSource ())
            {
              o << ::std::endl << "PressureSource: ";
              om.insert (o, *i.PressureSource ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextPressureSource ())
            {
              o << ::std::endl << "NextPressureSource: ";
              om.insert (o, *i.NextPressureSource ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.PressureSourceBaseline ())
            {
              o << ::std::endl << "PressureSourceBaseline: ";
              om.insert (o, *i.PressureSourceBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.ValveBreakdownPressure ())
            {
              o << ::std::endl << "ValveBreakdownPressure: ";
              om.insert (o, *i.ValveBreakdownPressure ());
            }
          }

          return o;
        }

        static
        const ::xsd::cxx::tree::std_ostream_initializer< 0, char, FluidCircuitPathData >
        _xsd_FluidCircuitPathData_std_ostream_init;
      }
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace mil
{
  namespace tatrc
  {
    namespace physiology
    {
      namespace datamodel
      {
      }
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace mil
{
  namespace tatrc
  {
    namespace physiology
    {
      namespace datamodel
      {
        void
        operator<< (::xercesc::DOMElement& e, const FluidCircuitPathData& i)
        {
          e << static_cast< const ::mil::tatrc::physiology::datamodel::CircuitPathData& > (i);

          // Resistance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Resistance ())
            {
              const FluidCircuitPathData::Resistance_type& x (*i.Resistance ());
              if (typeid (FluidCircuitPathData::Resistance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Resistance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Resistance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextResistance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextResistance ())
            {
              const FluidCircuitPathData::NextResistance_type& x (*i.NextResistance ());
              if (typeid (FluidCircuitPathData::NextResistance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextResistance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextResistance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // ResistanceBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.ResistanceBaseline ())
            {
              const FluidCircuitPathData::ResistanceBaseline_type& x (*i.ResistanceBaseline ());
              if (typeid (FluidCircuitPathData::ResistanceBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ResistanceBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "ResistanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // Compliance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Compliance ())
            {
              const FluidCircuitPathData::Compliance_type& x (*i.Compliance ());
              if (typeid (FluidCircuitPathData::Compliance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Compliance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Compliance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextCompliance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextCompliance ())
            {
              const FluidCircuitPathData::NextCompliance_type& x (*i.NextCompliance ());
              if (typeid (FluidCircuitPathData::NextCompliance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextCompliance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextCompliance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // ComplianceBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.ComplianceBaseline ())
            {
              const FluidCircuitPathData::ComplianceBaseline_type& x (*i.ComplianceBaseline ());
              if (typeid (FluidCircuitPathData::ComplianceBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ComplianceBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "ComplianceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // Inertance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Inertance ())
            {
              const FluidCircuitPathData::Inertance_type& x (*i.Inertance ());
              if (typeid (FluidCircuitPathData::Inertance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Inertance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Inertance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextInertance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextInertance ())
            {
              const FluidCircuitPathData::NextInertance_type& x (*i.NextInertance ());
              if (typeid (FluidCircuitPathData::NextInertance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextInertance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextInertance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // InertanceBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.InertanceBaseline ())
            {
              const FluidCircuitPathData::InertanceBaseline_type& x (*i.InertanceBaseline ());
              if (typeid (FluidCircuitPathData::InertanceBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "InertanceBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "InertanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // Flow
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Flow ())
            {
              const FluidCircuitPathData::Flow_type& x (*i.Flow ());
              if (typeid (FluidCircuitPathData::Flow_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Flow",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Flow",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextFlow
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextFlow ())
            {
              const FluidCircuitPathData::NextFlow_type& x (*i.NextFlow ());
              if (typeid (FluidCircuitPathData::NextFlow_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextFlow",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextFlow",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // FlowSource
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.FlowSource ())
            {
              const FluidCircuitPathData::FlowSource_type& x (*i.FlowSource ());
              if (typeid (FluidCircuitPathData::FlowSource_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "FlowSource",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "FlowSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextFlowSource
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextFlowSource ())
            {
              const FluidCircuitPathData::NextFlowSource_type& x (*i.NextFlowSource ());
              if (typeid (FluidCircuitPathData::NextFlowSource_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextFlowSource",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextFlowSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // FlowSourceBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.FlowSourceBaseline ())
            {
              const FluidCircuitPathData::FlowSourceBaseline_type& x (*i.FlowSourceBaseline ());
              if (typeid (FluidCircuitPathData::FlowSourceBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "FlowSourceBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "FlowSourceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // PressureSource
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.PressureSource ())
            {
              const FluidCircuitPathData::PressureSource_type& x (*i.PressureSource ());
              if (typeid (FluidCircuitPathData::PressureSource_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "PressureSource",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "PressureSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextPressureSource
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextPressureSource ())
            {
              const FluidCircuitPathData::NextPressureSource_type& x (*i.NextPressureSource ());
              if (typeid (FluidCircuitPathData::NextPressureSource_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextPressureSource",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextPressureSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // PressureSourceBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.PressureSourceBaseline ())
            {
              const FluidCircuitPathData::PressureSourceBaseline_type& x (*i.PressureSourceBaseline ());
              if (typeid (FluidCircuitPathData::PressureSourceBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "PressureSourceBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "PressureSourceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // ValveBreakdownPressure
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.ValveBreakdownPressure ())
            {
              const FluidCircuitPathData::ValveBreakdownPressure_type& x (*i.ValveBreakdownPressure ());
              if (typeid (FluidCircuitPathData::ValveBreakdownPressure_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ValveBreakdownPressure",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "ValveBreakdownPressure",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FluidCircuitPathData >
        _xsd_FluidCircuitPathData_type_serializer_init (
          "FluidCircuitPathData",
          "uri:/mil/tatrc/physiology/datamodel");
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

