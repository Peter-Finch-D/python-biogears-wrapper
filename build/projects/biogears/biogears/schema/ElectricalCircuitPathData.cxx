// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
#include "Properties.hxx"

//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "ElectricalCircuitPathData.hxx"

#include "ScalarElectricResistanceData.hxx"

#include "ScalarElectricCapacitanceData.hxx"

#include "ScalarElectricInductanceData.hxx"

#include "ScalarElectricCurrentData.hxx"

#include "ScalarElectricPotentialData.hxx"

namespace mil
{
  namespace tatrc
  {
    namespace physiology
    {
      namespace datamodel
      {
        // ElectricalCircuitPathData
        // 

        const ElectricalCircuitPathData::Resistance_optional& ElectricalCircuitPathData::
        Resistance () const
        {
          return this->Resistance_;
        }

        ElectricalCircuitPathData::Resistance_optional& ElectricalCircuitPathData::
        Resistance ()
        {
          return this->Resistance_;
        }

        void ElectricalCircuitPathData::
        Resistance (const Resistance_type& x)
        {
          this->Resistance_.set (x);
        }

        void ElectricalCircuitPathData::
        Resistance (const Resistance_optional& x)
        {
          this->Resistance_ = x;
        }

        void ElectricalCircuitPathData::
        Resistance (::std::unique_ptr< Resistance_type > x)
        {
          this->Resistance_.set (std::move (x));
        }

        const ElectricalCircuitPathData::NextResistance_optional& ElectricalCircuitPathData::
        NextResistance () const
        {
          return this->NextResistance_;
        }

        ElectricalCircuitPathData::NextResistance_optional& ElectricalCircuitPathData::
        NextResistance ()
        {
          return this->NextResistance_;
        }

        void ElectricalCircuitPathData::
        NextResistance (const NextResistance_type& x)
        {
          this->NextResistance_.set (x);
        }

        void ElectricalCircuitPathData::
        NextResistance (const NextResistance_optional& x)
        {
          this->NextResistance_ = x;
        }

        void ElectricalCircuitPathData::
        NextResistance (::std::unique_ptr< NextResistance_type > x)
        {
          this->NextResistance_.set (std::move (x));
        }

        const ElectricalCircuitPathData::ResistanceBaseline_optional& ElectricalCircuitPathData::
        ResistanceBaseline () const
        {
          return this->ResistanceBaseline_;
        }

        ElectricalCircuitPathData::ResistanceBaseline_optional& ElectricalCircuitPathData::
        ResistanceBaseline ()
        {
          return this->ResistanceBaseline_;
        }

        void ElectricalCircuitPathData::
        ResistanceBaseline (const ResistanceBaseline_type& x)
        {
          this->ResistanceBaseline_.set (x);
        }

        void ElectricalCircuitPathData::
        ResistanceBaseline (const ResistanceBaseline_optional& x)
        {
          this->ResistanceBaseline_ = x;
        }

        void ElectricalCircuitPathData::
        ResistanceBaseline (::std::unique_ptr< ResistanceBaseline_type > x)
        {
          this->ResistanceBaseline_.set (std::move (x));
        }

        const ElectricalCircuitPathData::Capacitance_optional& ElectricalCircuitPathData::
        Capacitance () const
        {
          return this->Capacitance_;
        }

        ElectricalCircuitPathData::Capacitance_optional& ElectricalCircuitPathData::
        Capacitance ()
        {
          return this->Capacitance_;
        }

        void ElectricalCircuitPathData::
        Capacitance (const Capacitance_type& x)
        {
          this->Capacitance_.set (x);
        }

        void ElectricalCircuitPathData::
        Capacitance (const Capacitance_optional& x)
        {
          this->Capacitance_ = x;
        }

        void ElectricalCircuitPathData::
        Capacitance (::std::unique_ptr< Capacitance_type > x)
        {
          this->Capacitance_.set (std::move (x));
        }

        const ElectricalCircuitPathData::NextCapacitance_optional& ElectricalCircuitPathData::
        NextCapacitance () const
        {
          return this->NextCapacitance_;
        }

        ElectricalCircuitPathData::NextCapacitance_optional& ElectricalCircuitPathData::
        NextCapacitance ()
        {
          return this->NextCapacitance_;
        }

        void ElectricalCircuitPathData::
        NextCapacitance (const NextCapacitance_type& x)
        {
          this->NextCapacitance_.set (x);
        }

        void ElectricalCircuitPathData::
        NextCapacitance (const NextCapacitance_optional& x)
        {
          this->NextCapacitance_ = x;
        }

        void ElectricalCircuitPathData::
        NextCapacitance (::std::unique_ptr< NextCapacitance_type > x)
        {
          this->NextCapacitance_.set (std::move (x));
        }

        const ElectricalCircuitPathData::CapacitanceBaseline_optional& ElectricalCircuitPathData::
        CapacitanceBaseline () const
        {
          return this->CapacitanceBaseline_;
        }

        ElectricalCircuitPathData::CapacitanceBaseline_optional& ElectricalCircuitPathData::
        CapacitanceBaseline ()
        {
          return this->CapacitanceBaseline_;
        }

        void ElectricalCircuitPathData::
        CapacitanceBaseline (const CapacitanceBaseline_type& x)
        {
          this->CapacitanceBaseline_.set (x);
        }

        void ElectricalCircuitPathData::
        CapacitanceBaseline (const CapacitanceBaseline_optional& x)
        {
          this->CapacitanceBaseline_ = x;
        }

        void ElectricalCircuitPathData::
        CapacitanceBaseline (::std::unique_ptr< CapacitanceBaseline_type > x)
        {
          this->CapacitanceBaseline_.set (std::move (x));
        }

        const ElectricalCircuitPathData::Inductance_optional& ElectricalCircuitPathData::
        Inductance () const
        {
          return this->Inductance_;
        }

        ElectricalCircuitPathData::Inductance_optional& ElectricalCircuitPathData::
        Inductance ()
        {
          return this->Inductance_;
        }

        void ElectricalCircuitPathData::
        Inductance (const Inductance_type& x)
        {
          this->Inductance_.set (x);
        }

        void ElectricalCircuitPathData::
        Inductance (const Inductance_optional& x)
        {
          this->Inductance_ = x;
        }

        void ElectricalCircuitPathData::
        Inductance (::std::unique_ptr< Inductance_type > x)
        {
          this->Inductance_.set (std::move (x));
        }

        const ElectricalCircuitPathData::NextInductance_optional& ElectricalCircuitPathData::
        NextInductance () const
        {
          return this->NextInductance_;
        }

        ElectricalCircuitPathData::NextInductance_optional& ElectricalCircuitPathData::
        NextInductance ()
        {
          return this->NextInductance_;
        }

        void ElectricalCircuitPathData::
        NextInductance (const NextInductance_type& x)
        {
          this->NextInductance_.set (x);
        }

        void ElectricalCircuitPathData::
        NextInductance (const NextInductance_optional& x)
        {
          this->NextInductance_ = x;
        }

        void ElectricalCircuitPathData::
        NextInductance (::std::unique_ptr< NextInductance_type > x)
        {
          this->NextInductance_.set (std::move (x));
        }

        const ElectricalCircuitPathData::InductanceBaseline_optional& ElectricalCircuitPathData::
        InductanceBaseline () const
        {
          return this->InductanceBaseline_;
        }

        ElectricalCircuitPathData::InductanceBaseline_optional& ElectricalCircuitPathData::
        InductanceBaseline ()
        {
          return this->InductanceBaseline_;
        }

        void ElectricalCircuitPathData::
        InductanceBaseline (const InductanceBaseline_type& x)
        {
          this->InductanceBaseline_.set (x);
        }

        void ElectricalCircuitPathData::
        InductanceBaseline (const InductanceBaseline_optional& x)
        {
          this->InductanceBaseline_ = x;
        }

        void ElectricalCircuitPathData::
        InductanceBaseline (::std::unique_ptr< InductanceBaseline_type > x)
        {
          this->InductanceBaseline_.set (std::move (x));
        }

        const ElectricalCircuitPathData::Current_optional& ElectricalCircuitPathData::
        Current () const
        {
          return this->Current_;
        }

        ElectricalCircuitPathData::Current_optional& ElectricalCircuitPathData::
        Current ()
        {
          return this->Current_;
        }

        void ElectricalCircuitPathData::
        Current (const Current_type& x)
        {
          this->Current_.set (x);
        }

        void ElectricalCircuitPathData::
        Current (const Current_optional& x)
        {
          this->Current_ = x;
        }

        void ElectricalCircuitPathData::
        Current (::std::unique_ptr< Current_type > x)
        {
          this->Current_.set (std::move (x));
        }

        const ElectricalCircuitPathData::NextCurrent_optional& ElectricalCircuitPathData::
        NextCurrent () const
        {
          return this->NextCurrent_;
        }

        ElectricalCircuitPathData::NextCurrent_optional& ElectricalCircuitPathData::
        NextCurrent ()
        {
          return this->NextCurrent_;
        }

        void ElectricalCircuitPathData::
        NextCurrent (const NextCurrent_type& x)
        {
          this->NextCurrent_.set (x);
        }

        void ElectricalCircuitPathData::
        NextCurrent (const NextCurrent_optional& x)
        {
          this->NextCurrent_ = x;
        }

        void ElectricalCircuitPathData::
        NextCurrent (::std::unique_ptr< NextCurrent_type > x)
        {
          this->NextCurrent_.set (std::move (x));
        }

        const ElectricalCircuitPathData::CurrentSource_optional& ElectricalCircuitPathData::
        CurrentSource () const
        {
          return this->CurrentSource_;
        }

        ElectricalCircuitPathData::CurrentSource_optional& ElectricalCircuitPathData::
        CurrentSource ()
        {
          return this->CurrentSource_;
        }

        void ElectricalCircuitPathData::
        CurrentSource (const CurrentSource_type& x)
        {
          this->CurrentSource_.set (x);
        }

        void ElectricalCircuitPathData::
        CurrentSource (const CurrentSource_optional& x)
        {
          this->CurrentSource_ = x;
        }

        void ElectricalCircuitPathData::
        CurrentSource (::std::unique_ptr< CurrentSource_type > x)
        {
          this->CurrentSource_.set (std::move (x));
        }

        const ElectricalCircuitPathData::NextCurrentSource_optional& ElectricalCircuitPathData::
        NextCurrentSource () const
        {
          return this->NextCurrentSource_;
        }

        ElectricalCircuitPathData::NextCurrentSource_optional& ElectricalCircuitPathData::
        NextCurrentSource ()
        {
          return this->NextCurrentSource_;
        }

        void ElectricalCircuitPathData::
        NextCurrentSource (const NextCurrentSource_type& x)
        {
          this->NextCurrentSource_.set (x);
        }

        void ElectricalCircuitPathData::
        NextCurrentSource (const NextCurrentSource_optional& x)
        {
          this->NextCurrentSource_ = x;
        }

        void ElectricalCircuitPathData::
        NextCurrentSource (::std::unique_ptr< NextCurrentSource_type > x)
        {
          this->NextCurrentSource_.set (std::move (x));
        }

        const ElectricalCircuitPathData::CurrentSourceBaseline_optional& ElectricalCircuitPathData::
        CurrentSourceBaseline () const
        {
          return this->CurrentSourceBaseline_;
        }

        ElectricalCircuitPathData::CurrentSourceBaseline_optional& ElectricalCircuitPathData::
        CurrentSourceBaseline ()
        {
          return this->CurrentSourceBaseline_;
        }

        void ElectricalCircuitPathData::
        CurrentSourceBaseline (const CurrentSourceBaseline_type& x)
        {
          this->CurrentSourceBaseline_.set (x);
        }

        void ElectricalCircuitPathData::
        CurrentSourceBaseline (const CurrentSourceBaseline_optional& x)
        {
          this->CurrentSourceBaseline_ = x;
        }

        void ElectricalCircuitPathData::
        CurrentSourceBaseline (::std::unique_ptr< CurrentSourceBaseline_type > x)
        {
          this->CurrentSourceBaseline_.set (std::move (x));
        }

        const ElectricalCircuitPathData::VoltageSource_optional& ElectricalCircuitPathData::
        VoltageSource () const
        {
          return this->VoltageSource_;
        }

        ElectricalCircuitPathData::VoltageSource_optional& ElectricalCircuitPathData::
        VoltageSource ()
        {
          return this->VoltageSource_;
        }

        void ElectricalCircuitPathData::
        VoltageSource (const VoltageSource_type& x)
        {
          this->VoltageSource_.set (x);
        }

        void ElectricalCircuitPathData::
        VoltageSource (const VoltageSource_optional& x)
        {
          this->VoltageSource_ = x;
        }

        void ElectricalCircuitPathData::
        VoltageSource (::std::unique_ptr< VoltageSource_type > x)
        {
          this->VoltageSource_.set (std::move (x));
        }

        const ElectricalCircuitPathData::NextVoltageSource_optional& ElectricalCircuitPathData::
        NextVoltageSource () const
        {
          return this->NextVoltageSource_;
        }

        ElectricalCircuitPathData::NextVoltageSource_optional& ElectricalCircuitPathData::
        NextVoltageSource ()
        {
          return this->NextVoltageSource_;
        }

        void ElectricalCircuitPathData::
        NextVoltageSource (const NextVoltageSource_type& x)
        {
          this->NextVoltageSource_.set (x);
        }

        void ElectricalCircuitPathData::
        NextVoltageSource (const NextVoltageSource_optional& x)
        {
          this->NextVoltageSource_ = x;
        }

        void ElectricalCircuitPathData::
        NextVoltageSource (::std::unique_ptr< NextVoltageSource_type > x)
        {
          this->NextVoltageSource_.set (std::move (x));
        }

        const ElectricalCircuitPathData::VoltageSourceBaseline_optional& ElectricalCircuitPathData::
        VoltageSourceBaseline () const
        {
          return this->VoltageSourceBaseline_;
        }

        ElectricalCircuitPathData::VoltageSourceBaseline_optional& ElectricalCircuitPathData::
        VoltageSourceBaseline ()
        {
          return this->VoltageSourceBaseline_;
        }

        void ElectricalCircuitPathData::
        VoltageSourceBaseline (const VoltageSourceBaseline_type& x)
        {
          this->VoltageSourceBaseline_.set (x);
        }

        void ElectricalCircuitPathData::
        VoltageSourceBaseline (const VoltageSourceBaseline_optional& x)
        {
          this->VoltageSourceBaseline_ = x;
        }

        void ElectricalCircuitPathData::
        VoltageSourceBaseline (::std::unique_ptr< VoltageSourceBaseline_type > x)
        {
          this->VoltageSourceBaseline_.set (std::move (x));
        }

        const ElectricalCircuitPathData::ValveBreakdownVoltage_optional& ElectricalCircuitPathData::
        ValveBreakdownVoltage () const
        {
          return this->ValveBreakdownVoltage_;
        }

        ElectricalCircuitPathData::ValveBreakdownVoltage_optional& ElectricalCircuitPathData::
        ValveBreakdownVoltage ()
        {
          return this->ValveBreakdownVoltage_;
        }

        void ElectricalCircuitPathData::
        ValveBreakdownVoltage (const ValveBreakdownVoltage_type& x)
        {
          this->ValveBreakdownVoltage_.set (x);
        }

        void ElectricalCircuitPathData::
        ValveBreakdownVoltage (const ValveBreakdownVoltage_optional& x)
        {
          this->ValveBreakdownVoltage_ = x;
        }

        void ElectricalCircuitPathData::
        ValveBreakdownVoltage (::std::unique_ptr< ValveBreakdownVoltage_type > x)
        {
          this->ValveBreakdownVoltage_.set (std::move (x));
        }
      }
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace mil
{
  namespace tatrc
  {
    namespace physiology
    {
      namespace datamodel
      {
        // ElectricalCircuitPathData
        //

        ElectricalCircuitPathData::
        ElectricalCircuitPathData ()
        : ::mil::tatrc::physiology::datamodel::CircuitPathData (),
          Resistance_ (this),
          NextResistance_ (this),
          ResistanceBaseline_ (this),
          Capacitance_ (this),
          NextCapacitance_ (this),
          CapacitanceBaseline_ (this),
          Inductance_ (this),
          NextInductance_ (this),
          InductanceBaseline_ (this),
          Current_ (this),
          NextCurrent_ (this),
          CurrentSource_ (this),
          NextCurrentSource_ (this),
          CurrentSourceBaseline_ (this),
          VoltageSource_ (this),
          NextVoltageSource_ (this),
          VoltageSourceBaseline_ (this),
          ValveBreakdownVoltage_ (this)
        {
        }

        ElectricalCircuitPathData::
        ElectricalCircuitPathData (const Name_type& Name,
                                   const SourceNode_type& SourceNode,
                                   const TargetNode_type& TargetNode)
        : ::mil::tatrc::physiology::datamodel::CircuitPathData (Name,
                                                                SourceNode,
                                                                TargetNode),
          Resistance_ (this),
          NextResistance_ (this),
          ResistanceBaseline_ (this),
          Capacitance_ (this),
          NextCapacitance_ (this),
          CapacitanceBaseline_ (this),
          Inductance_ (this),
          NextInductance_ (this),
          InductanceBaseline_ (this),
          Current_ (this),
          NextCurrent_ (this),
          CurrentSource_ (this),
          NextCurrentSource_ (this),
          CurrentSourceBaseline_ (this),
          VoltageSource_ (this),
          NextVoltageSource_ (this),
          VoltageSourceBaseline_ (this),
          ValveBreakdownVoltage_ (this)
        {
        }

        ElectricalCircuitPathData::
        ElectricalCircuitPathData (::std::unique_ptr< Name_type > Name,
                                   ::std::unique_ptr< SourceNode_type > SourceNode,
                                   ::std::unique_ptr< TargetNode_type > TargetNode)
        : ::mil::tatrc::physiology::datamodel::CircuitPathData (std::move (Name),
                                                                std::move (SourceNode),
                                                                std::move (TargetNode)),
          Resistance_ (this),
          NextResistance_ (this),
          ResistanceBaseline_ (this),
          Capacitance_ (this),
          NextCapacitance_ (this),
          CapacitanceBaseline_ (this),
          Inductance_ (this),
          NextInductance_ (this),
          InductanceBaseline_ (this),
          Current_ (this),
          NextCurrent_ (this),
          CurrentSource_ (this),
          NextCurrentSource_ (this),
          CurrentSourceBaseline_ (this),
          VoltageSource_ (this),
          NextVoltageSource_ (this),
          VoltageSourceBaseline_ (this),
          ValveBreakdownVoltage_ (this)
        {
        }

        ElectricalCircuitPathData::
        ElectricalCircuitPathData (const ElectricalCircuitPathData& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::CircuitPathData (x, f, c),
          Resistance_ (x.Resistance_, f, this),
          NextResistance_ (x.NextResistance_, f, this),
          ResistanceBaseline_ (x.ResistanceBaseline_, f, this),
          Capacitance_ (x.Capacitance_, f, this),
          NextCapacitance_ (x.NextCapacitance_, f, this),
          CapacitanceBaseline_ (x.CapacitanceBaseline_, f, this),
          Inductance_ (x.Inductance_, f, this),
          NextInductance_ (x.NextInductance_, f, this),
          InductanceBaseline_ (x.InductanceBaseline_, f, this),
          Current_ (x.Current_, f, this),
          NextCurrent_ (x.NextCurrent_, f, this),
          CurrentSource_ (x.CurrentSource_, f, this),
          NextCurrentSource_ (x.NextCurrentSource_, f, this),
          CurrentSourceBaseline_ (x.CurrentSourceBaseline_, f, this),
          VoltageSource_ (x.VoltageSource_, f, this),
          NextVoltageSource_ (x.NextVoltageSource_, f, this),
          VoltageSourceBaseline_ (x.VoltageSourceBaseline_, f, this),
          ValveBreakdownVoltage_ (x.ValveBreakdownVoltage_, f, this)
        {
        }

        ElectricalCircuitPathData::
        ElectricalCircuitPathData (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::CircuitPathData (e, f | ::xml_schema::flags::base, c),
          Resistance_ (this),
          NextResistance_ (this),
          ResistanceBaseline_ (this),
          Capacitance_ (this),
          NextCapacitance_ (this),
          CapacitanceBaseline_ (this),
          Inductance_ (this),
          NextInductance_ (this),
          InductanceBaseline_ (this),
          Current_ (this),
          NextCurrent_ (this),
          CurrentSource_ (this),
          NextCurrentSource_ (this),
          CurrentSourceBaseline_ (this),
          VoltageSource_ (this),
          NextVoltageSource_ (this),
          VoltageSourceBaseline_ (this),
          ValveBreakdownVoltage_ (this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
            this->parse (p, f);
          }
        }

        void ElectricalCircuitPathData::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::mil::tatrc::physiology::datamodel::CircuitPathData::parse (p, f);

          for (; p.more_content (); p.next_content (false))
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // Resistance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Resistance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Resistance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Resistance_)
                {
                  ::std::unique_ptr< Resistance_type > r (
                    dynamic_cast< Resistance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Resistance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextResistance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextResistance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextResistance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextResistance_)
                {
                  ::std::unique_ptr< NextResistance_type > r (
                    dynamic_cast< NextResistance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextResistance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // ResistanceBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ResistanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ResistanceBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->ResistanceBaseline_)
                {
                  ::std::unique_ptr< ResistanceBaseline_type > r (
                    dynamic_cast< ResistanceBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->ResistanceBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // Capacitance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Capacitance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Capacitance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Capacitance_)
                {
                  ::std::unique_ptr< Capacitance_type > r (
                    dynamic_cast< Capacitance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Capacitance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextCapacitance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextCapacitance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextCapacitance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextCapacitance_)
                {
                  ::std::unique_ptr< NextCapacitance_type > r (
                    dynamic_cast< NextCapacitance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextCapacitance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // CapacitanceBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "CapacitanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< CapacitanceBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->CapacitanceBaseline_)
                {
                  ::std::unique_ptr< CapacitanceBaseline_type > r (
                    dynamic_cast< CapacitanceBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->CapacitanceBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // Inductance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Inductance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Inductance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Inductance_)
                {
                  ::std::unique_ptr< Inductance_type > r (
                    dynamic_cast< Inductance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Inductance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextInductance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextInductance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextInductance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextInductance_)
                {
                  ::std::unique_ptr< NextInductance_type > r (
                    dynamic_cast< NextInductance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextInductance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // InductanceBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "InductanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< InductanceBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->InductanceBaseline_)
                {
                  ::std::unique_ptr< InductanceBaseline_type > r (
                    dynamic_cast< InductanceBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->InductanceBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // Current
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Current",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Current_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Current_)
                {
                  ::std::unique_ptr< Current_type > r (
                    dynamic_cast< Current_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Current_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextCurrent
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextCurrent",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextCurrent_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextCurrent_)
                {
                  ::std::unique_ptr< NextCurrent_type > r (
                    dynamic_cast< NextCurrent_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextCurrent_.set (::std::move (r));
                  continue;
                }
              }
            }

            // CurrentSource
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "CurrentSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< CurrentSource_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->CurrentSource_)
                {
                  ::std::unique_ptr< CurrentSource_type > r (
                    dynamic_cast< CurrentSource_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->CurrentSource_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextCurrentSource
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextCurrentSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextCurrentSource_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextCurrentSource_)
                {
                  ::std::unique_ptr< NextCurrentSource_type > r (
                    dynamic_cast< NextCurrentSource_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextCurrentSource_.set (::std::move (r));
                  continue;
                }
              }
            }

            // CurrentSourceBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "CurrentSourceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< CurrentSourceBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->CurrentSourceBaseline_)
                {
                  ::std::unique_ptr< CurrentSourceBaseline_type > r (
                    dynamic_cast< CurrentSourceBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->CurrentSourceBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // VoltageSource
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "VoltageSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< VoltageSource_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->VoltageSource_)
                {
                  ::std::unique_ptr< VoltageSource_type > r (
                    dynamic_cast< VoltageSource_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->VoltageSource_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextVoltageSource
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextVoltageSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextVoltageSource_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextVoltageSource_)
                {
                  ::std::unique_ptr< NextVoltageSource_type > r (
                    dynamic_cast< NextVoltageSource_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextVoltageSource_.set (::std::move (r));
                  continue;
                }
              }
            }

            // VoltageSourceBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "VoltageSourceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< VoltageSourceBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->VoltageSourceBaseline_)
                {
                  ::std::unique_ptr< VoltageSourceBaseline_type > r (
                    dynamic_cast< VoltageSourceBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->VoltageSourceBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // ValveBreakdownVoltage
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ValveBreakdownVoltage",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ValveBreakdownVoltage_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->ValveBreakdownVoltage_)
                {
                  ::std::unique_ptr< ValveBreakdownVoltage_type > r (
                    dynamic_cast< ValveBreakdownVoltage_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->ValveBreakdownVoltage_.set (::std::move (r));
                  continue;
                }
              }
            }

            break;
          }
        }

        ElectricalCircuitPathData* ElectricalCircuitPathData::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class ElectricalCircuitPathData (*this, f, c);
        }

        ElectricalCircuitPathData& ElectricalCircuitPathData::
        operator= (const ElectricalCircuitPathData& x)
        {
          if (this != &x)
          {
            static_cast< ::mil::tatrc::physiology::datamodel::CircuitPathData& > (*this) = x;
            this->Resistance_ = x.Resistance_;
            this->NextResistance_ = x.NextResistance_;
            this->ResistanceBaseline_ = x.ResistanceBaseline_;
            this->Capacitance_ = x.Capacitance_;
            this->NextCapacitance_ = x.NextCapacitance_;
            this->CapacitanceBaseline_ = x.CapacitanceBaseline_;
            this->Inductance_ = x.Inductance_;
            this->NextInductance_ = x.NextInductance_;
            this->InductanceBaseline_ = x.InductanceBaseline_;
            this->Current_ = x.Current_;
            this->NextCurrent_ = x.NextCurrent_;
            this->CurrentSource_ = x.CurrentSource_;
            this->NextCurrentSource_ = x.NextCurrentSource_;
            this->CurrentSourceBaseline_ = x.CurrentSourceBaseline_;
            this->VoltageSource_ = x.VoltageSource_;
            this->NextVoltageSource_ = x.NextVoltageSource_;
            this->VoltageSourceBaseline_ = x.VoltageSourceBaseline_;
            this->ValveBreakdownVoltage_ = x.ValveBreakdownVoltage_;
          }

          return *this;
        }

        ElectricalCircuitPathData::
        ~ElectricalCircuitPathData ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, ElectricalCircuitPathData >
        _xsd_ElectricalCircuitPathData_type_factory_init (
          "ElectricalCircuitPathData",
          "uri:/mil/tatrc/physiology/datamodel");
      }
    }
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace mil
{
  namespace tatrc
  {
    namespace physiology
    {
      namespace datamodel
      {
        ::std::ostream&
        operator<< (::std::ostream& o, const ElectricalCircuitPathData& i)
        {
          o << static_cast< const ::mil::tatrc::physiology::datamodel::CircuitPathData& > (i);

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Resistance ())
            {
              o << ::std::endl << "Resistance: ";
              om.insert (o, *i.Resistance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextResistance ())
            {
              o << ::std::endl << "NextResistance: ";
              om.insert (o, *i.NextResistance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.ResistanceBaseline ())
            {
              o << ::std::endl << "ResistanceBaseline: ";
              om.insert (o, *i.ResistanceBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Capacitance ())
            {
              o << ::std::endl << "Capacitance: ";
              om.insert (o, *i.Capacitance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextCapacitance ())
            {
              o << ::std::endl << "NextCapacitance: ";
              om.insert (o, *i.NextCapacitance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.CapacitanceBaseline ())
            {
              o << ::std::endl << "CapacitanceBaseline: ";
              om.insert (o, *i.CapacitanceBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Inductance ())
            {
              o << ::std::endl << "Inductance: ";
              om.insert (o, *i.Inductance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextInductance ())
            {
              o << ::std::endl << "NextInductance: ";
              om.insert (o, *i.NextInductance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.InductanceBaseline ())
            {
              o << ::std::endl << "InductanceBaseline: ";
              om.insert (o, *i.InductanceBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Current ())
            {
              o << ::std::endl << "Current: ";
              om.insert (o, *i.Current ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextCurrent ())
            {
              o << ::std::endl << "NextCurrent: ";
              om.insert (o, *i.NextCurrent ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.CurrentSource ())
            {
              o << ::std::endl << "CurrentSource: ";
              om.insert (o, *i.CurrentSource ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextCurrentSource ())
            {
              o << ::std::endl << "NextCurrentSource: ";
              om.insert (o, *i.NextCurrentSource ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.CurrentSourceBaseline ())
            {
              o << ::std::endl << "CurrentSourceBaseline: ";
              om.insert (o, *i.CurrentSourceBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.VoltageSource ())
            {
              o << ::std::endl << "VoltageSource: ";
              om.insert (o, *i.VoltageSource ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextVoltageSource ())
            {
              o << ::std::endl << "NextVoltageSource: ";
              om.insert (o, *i.NextVoltageSource ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.VoltageSourceBaseline ())
            {
              o << ::std::endl << "VoltageSourceBaseline: ";
              om.insert (o, *i.VoltageSourceBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.ValveBreakdownVoltage ())
            {
              o << ::std::endl << "ValveBreakdownVoltage: ";
              om.insert (o, *i.ValveBreakdownVoltage ());
            }
          }

          return o;
        }

        static
        const ::xsd::cxx::tree::std_ostream_initializer< 0, char, ElectricalCircuitPathData >
        _xsd_ElectricalCircuitPathData_std_ostream_init;
      }
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace mil
{
  namespace tatrc
  {
    namespace physiology
    {
      namespace datamodel
      {
      }
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace mil
{
  namespace tatrc
  {
    namespace physiology
    {
      namespace datamodel
      {
        void
        operator<< (::xercesc::DOMElement& e, const ElectricalCircuitPathData& i)
        {
          e << static_cast< const ::mil::tatrc::physiology::datamodel::CircuitPathData& > (i);

          // Resistance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Resistance ())
            {
              const ElectricalCircuitPathData::Resistance_type& x (*i.Resistance ());
              if (typeid (ElectricalCircuitPathData::Resistance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Resistance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Resistance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextResistance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextResistance ())
            {
              const ElectricalCircuitPathData::NextResistance_type& x (*i.NextResistance ());
              if (typeid (ElectricalCircuitPathData::NextResistance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextResistance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextResistance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // ResistanceBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.ResistanceBaseline ())
            {
              const ElectricalCircuitPathData::ResistanceBaseline_type& x (*i.ResistanceBaseline ());
              if (typeid (ElectricalCircuitPathData::ResistanceBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ResistanceBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "ResistanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // Capacitance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Capacitance ())
            {
              const ElectricalCircuitPathData::Capacitance_type& x (*i.Capacitance ());
              if (typeid (ElectricalCircuitPathData::Capacitance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Capacitance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Capacitance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextCapacitance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextCapacitance ())
            {
              const ElectricalCircuitPathData::NextCapacitance_type& x (*i.NextCapacitance ());
              if (typeid (ElectricalCircuitPathData::NextCapacitance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextCapacitance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextCapacitance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // CapacitanceBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.CapacitanceBaseline ())
            {
              const ElectricalCircuitPathData::CapacitanceBaseline_type& x (*i.CapacitanceBaseline ());
              if (typeid (ElectricalCircuitPathData::CapacitanceBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "CapacitanceBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "CapacitanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // Inductance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Inductance ())
            {
              const ElectricalCircuitPathData::Inductance_type& x (*i.Inductance ());
              if (typeid (ElectricalCircuitPathData::Inductance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Inductance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Inductance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextInductance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextInductance ())
            {
              const ElectricalCircuitPathData::NextInductance_type& x (*i.NextInductance ());
              if (typeid (ElectricalCircuitPathData::NextInductance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextInductance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextInductance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // InductanceBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.InductanceBaseline ())
            {
              const ElectricalCircuitPathData::InductanceBaseline_type& x (*i.InductanceBaseline ());
              if (typeid (ElectricalCircuitPathData::InductanceBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "InductanceBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "InductanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // Current
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Current ())
            {
              const ElectricalCircuitPathData::Current_type& x (*i.Current ());
              if (typeid (ElectricalCircuitPathData::Current_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Current",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Current",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextCurrent
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextCurrent ())
            {
              const ElectricalCircuitPathData::NextCurrent_type& x (*i.NextCurrent ());
              if (typeid (ElectricalCircuitPathData::NextCurrent_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextCurrent",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextCurrent",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // CurrentSource
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.CurrentSource ())
            {
              const ElectricalCircuitPathData::CurrentSource_type& x (*i.CurrentSource ());
              if (typeid (ElectricalCircuitPathData::CurrentSource_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "CurrentSource",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "CurrentSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextCurrentSource
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextCurrentSource ())
            {
              const ElectricalCircuitPathData::NextCurrentSource_type& x (*i.NextCurrentSource ());
              if (typeid (ElectricalCircuitPathData::NextCurrentSource_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextCurrentSource",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextCurrentSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // CurrentSourceBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.CurrentSourceBaseline ())
            {
              const ElectricalCircuitPathData::CurrentSourceBaseline_type& x (*i.CurrentSourceBaseline ());
              if (typeid (ElectricalCircuitPathData::CurrentSourceBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "CurrentSourceBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "CurrentSourceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // VoltageSource
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.VoltageSource ())
            {
              const ElectricalCircuitPathData::VoltageSource_type& x (*i.VoltageSource ());
              if (typeid (ElectricalCircuitPathData::VoltageSource_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "VoltageSource",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "VoltageSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextVoltageSource
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextVoltageSource ())
            {
              const ElectricalCircuitPathData::NextVoltageSource_type& x (*i.NextVoltageSource ());
              if (typeid (ElectricalCircuitPathData::NextVoltageSource_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextVoltageSource",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextVoltageSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // VoltageSourceBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.VoltageSourceBaseline ())
            {
              const ElectricalCircuitPathData::VoltageSourceBaseline_type& x (*i.VoltageSourceBaseline ());
              if (typeid (ElectricalCircuitPathData::VoltageSourceBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "VoltageSourceBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "VoltageSourceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // ValveBreakdownVoltage
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.ValveBreakdownVoltage ())
            {
              const ElectricalCircuitPathData::ValveBreakdownVoltage_type& x (*i.ValveBreakdownVoltage ());
              if (typeid (ElectricalCircuitPathData::ValveBreakdownVoltage_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ValveBreakdownVoltage",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "ValveBreakdownVoltage",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ElectricalCircuitPathData >
        _xsd_ElectricalCircuitPathData_type_serializer_init (
          "ElectricalCircuitPathData",
          "uri:/mil/tatrc/physiology/datamodel");
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

