// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
#include "Properties.hxx"

//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "PulmonaryFunctionTestData.hxx"

#include "ScalarVolumeData.hxx"

#include "ScalarVolumePerTimeData.hxx"

#include "FunctionVolumeVsTimeData.hxx"

namespace mil
{
  namespace tatrc
  {
    namespace physiology
    {
      namespace datamodel
      {
        // PulmonaryFunctionTestData
        // 

        const PulmonaryFunctionTestData::ExpiratoryReserveVolume_optional& PulmonaryFunctionTestData::
        ExpiratoryReserveVolume () const
        {
          return this->ExpiratoryReserveVolume_;
        }

        PulmonaryFunctionTestData::ExpiratoryReserveVolume_optional& PulmonaryFunctionTestData::
        ExpiratoryReserveVolume ()
        {
          return this->ExpiratoryReserveVolume_;
        }

        void PulmonaryFunctionTestData::
        ExpiratoryReserveVolume (const ExpiratoryReserveVolume_type& x)
        {
          this->ExpiratoryReserveVolume_.set (x);
        }

        void PulmonaryFunctionTestData::
        ExpiratoryReserveVolume (const ExpiratoryReserveVolume_optional& x)
        {
          this->ExpiratoryReserveVolume_ = x;
        }

        void PulmonaryFunctionTestData::
        ExpiratoryReserveVolume (::std::unique_ptr< ExpiratoryReserveVolume_type > x)
        {
          this->ExpiratoryReserveVolume_.set (std::move (x));
        }

        const PulmonaryFunctionTestData::ForcedVitalCapacity_optional& PulmonaryFunctionTestData::
        ForcedVitalCapacity () const
        {
          return this->ForcedVitalCapacity_;
        }

        PulmonaryFunctionTestData::ForcedVitalCapacity_optional& PulmonaryFunctionTestData::
        ForcedVitalCapacity ()
        {
          return this->ForcedVitalCapacity_;
        }

        void PulmonaryFunctionTestData::
        ForcedVitalCapacity (const ForcedVitalCapacity_type& x)
        {
          this->ForcedVitalCapacity_.set (x);
        }

        void PulmonaryFunctionTestData::
        ForcedVitalCapacity (const ForcedVitalCapacity_optional& x)
        {
          this->ForcedVitalCapacity_ = x;
        }

        void PulmonaryFunctionTestData::
        ForcedVitalCapacity (::std::unique_ptr< ForcedVitalCapacity_type > x)
        {
          this->ForcedVitalCapacity_.set (std::move (x));
        }

        const PulmonaryFunctionTestData::ForcedExpiratoryVolume_optional& PulmonaryFunctionTestData::
        ForcedExpiratoryVolume () const
        {
          return this->ForcedExpiratoryVolume_;
        }

        PulmonaryFunctionTestData::ForcedExpiratoryVolume_optional& PulmonaryFunctionTestData::
        ForcedExpiratoryVolume ()
        {
          return this->ForcedExpiratoryVolume_;
        }

        void PulmonaryFunctionTestData::
        ForcedExpiratoryVolume (const ForcedExpiratoryVolume_type& x)
        {
          this->ForcedExpiratoryVolume_.set (x);
        }

        void PulmonaryFunctionTestData::
        ForcedExpiratoryVolume (const ForcedExpiratoryVolume_optional& x)
        {
          this->ForcedExpiratoryVolume_ = x;
        }

        void PulmonaryFunctionTestData::
        ForcedExpiratoryVolume (::std::unique_ptr< ForcedExpiratoryVolume_type > x)
        {
          this->ForcedExpiratoryVolume_.set (std::move (x));
        }

        const PulmonaryFunctionTestData::ForcedExpiratoryFlow_optional& PulmonaryFunctionTestData::
        ForcedExpiratoryFlow () const
        {
          return this->ForcedExpiratoryFlow_;
        }

        PulmonaryFunctionTestData::ForcedExpiratoryFlow_optional& PulmonaryFunctionTestData::
        ForcedExpiratoryFlow ()
        {
          return this->ForcedExpiratoryFlow_;
        }

        void PulmonaryFunctionTestData::
        ForcedExpiratoryFlow (const ForcedExpiratoryFlow_type& x)
        {
          this->ForcedExpiratoryFlow_.set (x);
        }

        void PulmonaryFunctionTestData::
        ForcedExpiratoryFlow (const ForcedExpiratoryFlow_optional& x)
        {
          this->ForcedExpiratoryFlow_ = x;
        }

        void PulmonaryFunctionTestData::
        ForcedExpiratoryFlow (::std::unique_ptr< ForcedExpiratoryFlow_type > x)
        {
          this->ForcedExpiratoryFlow_.set (std::move (x));
        }

        const PulmonaryFunctionTestData::FunctionalResidualCapacity_optional& PulmonaryFunctionTestData::
        FunctionalResidualCapacity () const
        {
          return this->FunctionalResidualCapacity_;
        }

        PulmonaryFunctionTestData::FunctionalResidualCapacity_optional& PulmonaryFunctionTestData::
        FunctionalResidualCapacity ()
        {
          return this->FunctionalResidualCapacity_;
        }

        void PulmonaryFunctionTestData::
        FunctionalResidualCapacity (const FunctionalResidualCapacity_type& x)
        {
          this->FunctionalResidualCapacity_.set (x);
        }

        void PulmonaryFunctionTestData::
        FunctionalResidualCapacity (const FunctionalResidualCapacity_optional& x)
        {
          this->FunctionalResidualCapacity_ = x;
        }

        void PulmonaryFunctionTestData::
        FunctionalResidualCapacity (::std::unique_ptr< FunctionalResidualCapacity_type > x)
        {
          this->FunctionalResidualCapacity_.set (std::move (x));
        }

        const PulmonaryFunctionTestData::InspiratoryCapacity_optional& PulmonaryFunctionTestData::
        InspiratoryCapacity () const
        {
          return this->InspiratoryCapacity_;
        }

        PulmonaryFunctionTestData::InspiratoryCapacity_optional& PulmonaryFunctionTestData::
        InspiratoryCapacity ()
        {
          return this->InspiratoryCapacity_;
        }

        void PulmonaryFunctionTestData::
        InspiratoryCapacity (const InspiratoryCapacity_type& x)
        {
          this->InspiratoryCapacity_.set (x);
        }

        void PulmonaryFunctionTestData::
        InspiratoryCapacity (const InspiratoryCapacity_optional& x)
        {
          this->InspiratoryCapacity_ = x;
        }

        void PulmonaryFunctionTestData::
        InspiratoryCapacity (::std::unique_ptr< InspiratoryCapacity_type > x)
        {
          this->InspiratoryCapacity_.set (std::move (x));
        }

        const PulmonaryFunctionTestData::InspiratoryReserveVolume_optional& PulmonaryFunctionTestData::
        InspiratoryReserveVolume () const
        {
          return this->InspiratoryReserveVolume_;
        }

        PulmonaryFunctionTestData::InspiratoryReserveVolume_optional& PulmonaryFunctionTestData::
        InspiratoryReserveVolume ()
        {
          return this->InspiratoryReserveVolume_;
        }

        void PulmonaryFunctionTestData::
        InspiratoryReserveVolume (const InspiratoryReserveVolume_type& x)
        {
          this->InspiratoryReserveVolume_.set (x);
        }

        void PulmonaryFunctionTestData::
        InspiratoryReserveVolume (const InspiratoryReserveVolume_optional& x)
        {
          this->InspiratoryReserveVolume_ = x;
        }

        void PulmonaryFunctionTestData::
        InspiratoryReserveVolume (::std::unique_ptr< InspiratoryReserveVolume_type > x)
        {
          this->InspiratoryReserveVolume_.set (std::move (x));
        }

        const PulmonaryFunctionTestData::MaximumVoluntaryVentilation_optional& PulmonaryFunctionTestData::
        MaximumVoluntaryVentilation () const
        {
          return this->MaximumVoluntaryVentilation_;
        }

        PulmonaryFunctionTestData::MaximumVoluntaryVentilation_optional& PulmonaryFunctionTestData::
        MaximumVoluntaryVentilation ()
        {
          return this->MaximumVoluntaryVentilation_;
        }

        void PulmonaryFunctionTestData::
        MaximumVoluntaryVentilation (const MaximumVoluntaryVentilation_type& x)
        {
          this->MaximumVoluntaryVentilation_.set (x);
        }

        void PulmonaryFunctionTestData::
        MaximumVoluntaryVentilation (const MaximumVoluntaryVentilation_optional& x)
        {
          this->MaximumVoluntaryVentilation_ = x;
        }

        void PulmonaryFunctionTestData::
        MaximumVoluntaryVentilation (::std::unique_ptr< MaximumVoluntaryVentilation_type > x)
        {
          this->MaximumVoluntaryVentilation_.set (std::move (x));
        }

        const PulmonaryFunctionTestData::PeakExpiratoryFlow_optional& PulmonaryFunctionTestData::
        PeakExpiratoryFlow () const
        {
          return this->PeakExpiratoryFlow_;
        }

        PulmonaryFunctionTestData::PeakExpiratoryFlow_optional& PulmonaryFunctionTestData::
        PeakExpiratoryFlow ()
        {
          return this->PeakExpiratoryFlow_;
        }

        void PulmonaryFunctionTestData::
        PeakExpiratoryFlow (const PeakExpiratoryFlow_type& x)
        {
          this->PeakExpiratoryFlow_.set (x);
        }

        void PulmonaryFunctionTestData::
        PeakExpiratoryFlow (const PeakExpiratoryFlow_optional& x)
        {
          this->PeakExpiratoryFlow_ = x;
        }

        void PulmonaryFunctionTestData::
        PeakExpiratoryFlow (::std::unique_ptr< PeakExpiratoryFlow_type > x)
        {
          this->PeakExpiratoryFlow_.set (std::move (x));
        }

        const PulmonaryFunctionTestData::ResidualVolume_optional& PulmonaryFunctionTestData::
        ResidualVolume () const
        {
          return this->ResidualVolume_;
        }

        PulmonaryFunctionTestData::ResidualVolume_optional& PulmonaryFunctionTestData::
        ResidualVolume ()
        {
          return this->ResidualVolume_;
        }

        void PulmonaryFunctionTestData::
        ResidualVolume (const ResidualVolume_type& x)
        {
          this->ResidualVolume_.set (x);
        }

        void PulmonaryFunctionTestData::
        ResidualVolume (const ResidualVolume_optional& x)
        {
          this->ResidualVolume_ = x;
        }

        void PulmonaryFunctionTestData::
        ResidualVolume (::std::unique_ptr< ResidualVolume_type > x)
        {
          this->ResidualVolume_.set (std::move (x));
        }

        const PulmonaryFunctionTestData::SlowVitalCapacity_optional& PulmonaryFunctionTestData::
        SlowVitalCapacity () const
        {
          return this->SlowVitalCapacity_;
        }

        PulmonaryFunctionTestData::SlowVitalCapacity_optional& PulmonaryFunctionTestData::
        SlowVitalCapacity ()
        {
          return this->SlowVitalCapacity_;
        }

        void PulmonaryFunctionTestData::
        SlowVitalCapacity (const SlowVitalCapacity_type& x)
        {
          this->SlowVitalCapacity_.set (x);
        }

        void PulmonaryFunctionTestData::
        SlowVitalCapacity (const SlowVitalCapacity_optional& x)
        {
          this->SlowVitalCapacity_ = x;
        }

        void PulmonaryFunctionTestData::
        SlowVitalCapacity (::std::unique_ptr< SlowVitalCapacity_type > x)
        {
          this->SlowVitalCapacity_.set (std::move (x));
        }

        const PulmonaryFunctionTestData::TotalLungCapacity_optional& PulmonaryFunctionTestData::
        TotalLungCapacity () const
        {
          return this->TotalLungCapacity_;
        }

        PulmonaryFunctionTestData::TotalLungCapacity_optional& PulmonaryFunctionTestData::
        TotalLungCapacity ()
        {
          return this->TotalLungCapacity_;
        }

        void PulmonaryFunctionTestData::
        TotalLungCapacity (const TotalLungCapacity_type& x)
        {
          this->TotalLungCapacity_.set (x);
        }

        void PulmonaryFunctionTestData::
        TotalLungCapacity (const TotalLungCapacity_optional& x)
        {
          this->TotalLungCapacity_ = x;
        }

        void PulmonaryFunctionTestData::
        TotalLungCapacity (::std::unique_ptr< TotalLungCapacity_type > x)
        {
          this->TotalLungCapacity_.set (std::move (x));
        }

        const PulmonaryFunctionTestData::VitalCapacity_optional& PulmonaryFunctionTestData::
        VitalCapacity () const
        {
          return this->VitalCapacity_;
        }

        PulmonaryFunctionTestData::VitalCapacity_optional& PulmonaryFunctionTestData::
        VitalCapacity ()
        {
          return this->VitalCapacity_;
        }

        void PulmonaryFunctionTestData::
        VitalCapacity (const VitalCapacity_type& x)
        {
          this->VitalCapacity_.set (x);
        }

        void PulmonaryFunctionTestData::
        VitalCapacity (const VitalCapacity_optional& x)
        {
          this->VitalCapacity_ = x;
        }

        void PulmonaryFunctionTestData::
        VitalCapacity (::std::unique_ptr< VitalCapacity_type > x)
        {
          this->VitalCapacity_.set (std::move (x));
        }

        const PulmonaryFunctionTestData::LungVolumePlot_optional& PulmonaryFunctionTestData::
        LungVolumePlot () const
        {
          return this->LungVolumePlot_;
        }

        PulmonaryFunctionTestData::LungVolumePlot_optional& PulmonaryFunctionTestData::
        LungVolumePlot ()
        {
          return this->LungVolumePlot_;
        }

        void PulmonaryFunctionTestData::
        LungVolumePlot (const LungVolumePlot_type& x)
        {
          this->LungVolumePlot_.set (x);
        }

        void PulmonaryFunctionTestData::
        LungVolumePlot (const LungVolumePlot_optional& x)
        {
          this->LungVolumePlot_ = x;
        }

        void PulmonaryFunctionTestData::
        LungVolumePlot (::std::unique_ptr< LungVolumePlot_type > x)
        {
          this->LungVolumePlot_.set (std::move (x));
        }
      }
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace mil
{
  namespace tatrc
  {
    namespace physiology
    {
      namespace datamodel
      {
        // PulmonaryFunctionTestData
        //

        PulmonaryFunctionTestData::
        PulmonaryFunctionTestData ()
        : ::mil::tatrc::physiology::datamodel::PatientAssessmentData (),
          ExpiratoryReserveVolume_ (this),
          ForcedVitalCapacity_ (this),
          ForcedExpiratoryVolume_ (this),
          ForcedExpiratoryFlow_ (this),
          FunctionalResidualCapacity_ (this),
          InspiratoryCapacity_ (this),
          InspiratoryReserveVolume_ (this),
          MaximumVoluntaryVentilation_ (this),
          PeakExpiratoryFlow_ (this),
          ResidualVolume_ (this),
          SlowVitalCapacity_ (this),
          TotalLungCapacity_ (this),
          VitalCapacity_ (this),
          LungVolumePlot_ (this)
        {
        }

        PulmonaryFunctionTestData::
        PulmonaryFunctionTestData (const PulmonaryFunctionTestData& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::PatientAssessmentData (x, f, c),
          ExpiratoryReserveVolume_ (x.ExpiratoryReserveVolume_, f, this),
          ForcedVitalCapacity_ (x.ForcedVitalCapacity_, f, this),
          ForcedExpiratoryVolume_ (x.ForcedExpiratoryVolume_, f, this),
          ForcedExpiratoryFlow_ (x.ForcedExpiratoryFlow_, f, this),
          FunctionalResidualCapacity_ (x.FunctionalResidualCapacity_, f, this),
          InspiratoryCapacity_ (x.InspiratoryCapacity_, f, this),
          InspiratoryReserveVolume_ (x.InspiratoryReserveVolume_, f, this),
          MaximumVoluntaryVentilation_ (x.MaximumVoluntaryVentilation_, f, this),
          PeakExpiratoryFlow_ (x.PeakExpiratoryFlow_, f, this),
          ResidualVolume_ (x.ResidualVolume_, f, this),
          SlowVitalCapacity_ (x.SlowVitalCapacity_, f, this),
          TotalLungCapacity_ (x.TotalLungCapacity_, f, this),
          VitalCapacity_ (x.VitalCapacity_, f, this),
          LungVolumePlot_ (x.LungVolumePlot_, f, this)
        {
        }

        PulmonaryFunctionTestData::
        PulmonaryFunctionTestData (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::PatientAssessmentData (e, f | ::xml_schema::flags::base, c),
          ExpiratoryReserveVolume_ (this),
          ForcedVitalCapacity_ (this),
          ForcedExpiratoryVolume_ (this),
          ForcedExpiratoryFlow_ (this),
          FunctionalResidualCapacity_ (this),
          InspiratoryCapacity_ (this),
          InspiratoryReserveVolume_ (this),
          MaximumVoluntaryVentilation_ (this),
          PeakExpiratoryFlow_ (this),
          ResidualVolume_ (this),
          SlowVitalCapacity_ (this),
          TotalLungCapacity_ (this),
          VitalCapacity_ (this),
          LungVolumePlot_ (this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
            this->parse (p, f);
          }
        }

        void PulmonaryFunctionTestData::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::mil::tatrc::physiology::datamodel::PatientAssessmentData::parse (p, f);

          for (; p.more_content (); p.next_content (false))
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // ExpiratoryReserveVolume
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ExpiratoryReserveVolume",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ExpiratoryReserveVolume_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->ExpiratoryReserveVolume_)
                {
                  ::std::unique_ptr< ExpiratoryReserveVolume_type > r (
                    dynamic_cast< ExpiratoryReserveVolume_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->ExpiratoryReserveVolume_.set (::std::move (r));
                  continue;
                }
              }
            }

            // ForcedVitalCapacity
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ForcedVitalCapacity",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ForcedVitalCapacity_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->ForcedVitalCapacity_)
                {
                  ::std::unique_ptr< ForcedVitalCapacity_type > r (
                    dynamic_cast< ForcedVitalCapacity_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->ForcedVitalCapacity_.set (::std::move (r));
                  continue;
                }
              }
            }

            // ForcedExpiratoryVolume
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ForcedExpiratoryVolume",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ForcedExpiratoryVolume_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->ForcedExpiratoryVolume_)
                {
                  ::std::unique_ptr< ForcedExpiratoryVolume_type > r (
                    dynamic_cast< ForcedExpiratoryVolume_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->ForcedExpiratoryVolume_.set (::std::move (r));
                  continue;
                }
              }
            }

            // ForcedExpiratoryFlow
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ForcedExpiratoryFlow",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ForcedExpiratoryFlow_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->ForcedExpiratoryFlow_)
                {
                  ::std::unique_ptr< ForcedExpiratoryFlow_type > r (
                    dynamic_cast< ForcedExpiratoryFlow_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->ForcedExpiratoryFlow_.set (::std::move (r));
                  continue;
                }
              }
            }

            // FunctionalResidualCapacity
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "FunctionalResidualCapacity",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< FunctionalResidualCapacity_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->FunctionalResidualCapacity_)
                {
                  ::std::unique_ptr< FunctionalResidualCapacity_type > r (
                    dynamic_cast< FunctionalResidualCapacity_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->FunctionalResidualCapacity_.set (::std::move (r));
                  continue;
                }
              }
            }

            // InspiratoryCapacity
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "InspiratoryCapacity",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< InspiratoryCapacity_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->InspiratoryCapacity_)
                {
                  ::std::unique_ptr< InspiratoryCapacity_type > r (
                    dynamic_cast< InspiratoryCapacity_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->InspiratoryCapacity_.set (::std::move (r));
                  continue;
                }
              }
            }

            // InspiratoryReserveVolume
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "InspiratoryReserveVolume",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< InspiratoryReserveVolume_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->InspiratoryReserveVolume_)
                {
                  ::std::unique_ptr< InspiratoryReserveVolume_type > r (
                    dynamic_cast< InspiratoryReserveVolume_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->InspiratoryReserveVolume_.set (::std::move (r));
                  continue;
                }
              }
            }

            // MaximumVoluntaryVentilation
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "MaximumVoluntaryVentilation",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< MaximumVoluntaryVentilation_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->MaximumVoluntaryVentilation_)
                {
                  ::std::unique_ptr< MaximumVoluntaryVentilation_type > r (
                    dynamic_cast< MaximumVoluntaryVentilation_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->MaximumVoluntaryVentilation_.set (::std::move (r));
                  continue;
                }
              }
            }

            // PeakExpiratoryFlow
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "PeakExpiratoryFlow",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< PeakExpiratoryFlow_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->PeakExpiratoryFlow_)
                {
                  ::std::unique_ptr< PeakExpiratoryFlow_type > r (
                    dynamic_cast< PeakExpiratoryFlow_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->PeakExpiratoryFlow_.set (::std::move (r));
                  continue;
                }
              }
            }

            // ResidualVolume
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ResidualVolume",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ResidualVolume_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->ResidualVolume_)
                {
                  ::std::unique_ptr< ResidualVolume_type > r (
                    dynamic_cast< ResidualVolume_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->ResidualVolume_.set (::std::move (r));
                  continue;
                }
              }
            }

            // SlowVitalCapacity
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "SlowVitalCapacity",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< SlowVitalCapacity_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->SlowVitalCapacity_)
                {
                  ::std::unique_ptr< SlowVitalCapacity_type > r (
                    dynamic_cast< SlowVitalCapacity_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->SlowVitalCapacity_.set (::std::move (r));
                  continue;
                }
              }
            }

            // TotalLungCapacity
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "TotalLungCapacity",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< TotalLungCapacity_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->TotalLungCapacity_)
                {
                  ::std::unique_ptr< TotalLungCapacity_type > r (
                    dynamic_cast< TotalLungCapacity_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->TotalLungCapacity_.set (::std::move (r));
                  continue;
                }
              }
            }

            // VitalCapacity
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "VitalCapacity",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< VitalCapacity_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->VitalCapacity_)
                {
                  ::std::unique_ptr< VitalCapacity_type > r (
                    dynamic_cast< VitalCapacity_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->VitalCapacity_.set (::std::move (r));
                  continue;
                }
              }
            }

            // LungVolumePlot
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "LungVolumePlot",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< LungVolumePlot_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->LungVolumePlot_)
                {
                  ::std::unique_ptr< LungVolumePlot_type > r (
                    dynamic_cast< LungVolumePlot_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->LungVolumePlot_.set (::std::move (r));
                  continue;
                }
              }
            }

            break;
          }
        }

        PulmonaryFunctionTestData* PulmonaryFunctionTestData::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class PulmonaryFunctionTestData (*this, f, c);
        }

        PulmonaryFunctionTestData& PulmonaryFunctionTestData::
        operator= (const PulmonaryFunctionTestData& x)
        {
          if (this != &x)
          {
            static_cast< ::mil::tatrc::physiology::datamodel::PatientAssessmentData& > (*this) = x;
            this->ExpiratoryReserveVolume_ = x.ExpiratoryReserveVolume_;
            this->ForcedVitalCapacity_ = x.ForcedVitalCapacity_;
            this->ForcedExpiratoryVolume_ = x.ForcedExpiratoryVolume_;
            this->ForcedExpiratoryFlow_ = x.ForcedExpiratoryFlow_;
            this->FunctionalResidualCapacity_ = x.FunctionalResidualCapacity_;
            this->InspiratoryCapacity_ = x.InspiratoryCapacity_;
            this->InspiratoryReserveVolume_ = x.InspiratoryReserveVolume_;
            this->MaximumVoluntaryVentilation_ = x.MaximumVoluntaryVentilation_;
            this->PeakExpiratoryFlow_ = x.PeakExpiratoryFlow_;
            this->ResidualVolume_ = x.ResidualVolume_;
            this->SlowVitalCapacity_ = x.SlowVitalCapacity_;
            this->TotalLungCapacity_ = x.TotalLungCapacity_;
            this->VitalCapacity_ = x.VitalCapacity_;
            this->LungVolumePlot_ = x.LungVolumePlot_;
          }

          return *this;
        }

        PulmonaryFunctionTestData::
        ~PulmonaryFunctionTestData ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, PulmonaryFunctionTestData >
        _xsd_PulmonaryFunctionTestData_type_factory_init (
          "PulmonaryFunctionTestData",
          "uri:/mil/tatrc/physiology/datamodel");
      }
    }
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace mil
{
  namespace tatrc
  {
    namespace physiology
    {
      namespace datamodel
      {
        ::std::ostream&
        operator<< (::std::ostream& o, const PulmonaryFunctionTestData& i)
        {
          o << static_cast< const ::mil::tatrc::physiology::datamodel::PatientAssessmentData& > (i);

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.ExpiratoryReserveVolume ())
            {
              o << ::std::endl << "ExpiratoryReserveVolume: ";
              om.insert (o, *i.ExpiratoryReserveVolume ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.ForcedVitalCapacity ())
            {
              o << ::std::endl << "ForcedVitalCapacity: ";
              om.insert (o, *i.ForcedVitalCapacity ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.ForcedExpiratoryVolume ())
            {
              o << ::std::endl << "ForcedExpiratoryVolume: ";
              om.insert (o, *i.ForcedExpiratoryVolume ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.ForcedExpiratoryFlow ())
            {
              o << ::std::endl << "ForcedExpiratoryFlow: ";
              om.insert (o, *i.ForcedExpiratoryFlow ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.FunctionalResidualCapacity ())
            {
              o << ::std::endl << "FunctionalResidualCapacity: ";
              om.insert (o, *i.FunctionalResidualCapacity ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.InspiratoryCapacity ())
            {
              o << ::std::endl << "InspiratoryCapacity: ";
              om.insert (o, *i.InspiratoryCapacity ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.InspiratoryReserveVolume ())
            {
              o << ::std::endl << "InspiratoryReserveVolume: ";
              om.insert (o, *i.InspiratoryReserveVolume ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.MaximumVoluntaryVentilation ())
            {
              o << ::std::endl << "MaximumVoluntaryVentilation: ";
              om.insert (o, *i.MaximumVoluntaryVentilation ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.PeakExpiratoryFlow ())
            {
              o << ::std::endl << "PeakExpiratoryFlow: ";
              om.insert (o, *i.PeakExpiratoryFlow ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.ResidualVolume ())
            {
              o << ::std::endl << "ResidualVolume: ";
              om.insert (o, *i.ResidualVolume ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.SlowVitalCapacity ())
            {
              o << ::std::endl << "SlowVitalCapacity: ";
              om.insert (o, *i.SlowVitalCapacity ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.TotalLungCapacity ())
            {
              o << ::std::endl << "TotalLungCapacity: ";
              om.insert (o, *i.TotalLungCapacity ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.VitalCapacity ())
            {
              o << ::std::endl << "VitalCapacity: ";
              om.insert (o, *i.VitalCapacity ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.LungVolumePlot ())
            {
              o << ::std::endl << "LungVolumePlot: ";
              om.insert (o, *i.LungVolumePlot ());
            }
          }

          return o;
        }

        static
        const ::xsd::cxx::tree::std_ostream_initializer< 0, char, PulmonaryFunctionTestData >
        _xsd_PulmonaryFunctionTestData_std_ostream_init;
      }
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace mil
{
  namespace tatrc
  {
    namespace physiology
    {
      namespace datamodel
      {
      }
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace mil
{
  namespace tatrc
  {
    namespace physiology
    {
      namespace datamodel
      {
        void
        operator<< (::xercesc::DOMElement& e, const PulmonaryFunctionTestData& i)
        {
          e << static_cast< const ::mil::tatrc::physiology::datamodel::PatientAssessmentData& > (i);

          // ExpiratoryReserveVolume
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.ExpiratoryReserveVolume ())
            {
              const PulmonaryFunctionTestData::ExpiratoryReserveVolume_type& x (*i.ExpiratoryReserveVolume ());
              if (typeid (PulmonaryFunctionTestData::ExpiratoryReserveVolume_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ExpiratoryReserveVolume",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "ExpiratoryReserveVolume",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // ForcedVitalCapacity
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.ForcedVitalCapacity ())
            {
              const PulmonaryFunctionTestData::ForcedVitalCapacity_type& x (*i.ForcedVitalCapacity ());
              if (typeid (PulmonaryFunctionTestData::ForcedVitalCapacity_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ForcedVitalCapacity",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "ForcedVitalCapacity",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // ForcedExpiratoryVolume
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.ForcedExpiratoryVolume ())
            {
              const PulmonaryFunctionTestData::ForcedExpiratoryVolume_type& x (*i.ForcedExpiratoryVolume ());
              if (typeid (PulmonaryFunctionTestData::ForcedExpiratoryVolume_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ForcedExpiratoryVolume",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "ForcedExpiratoryVolume",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // ForcedExpiratoryFlow
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.ForcedExpiratoryFlow ())
            {
              const PulmonaryFunctionTestData::ForcedExpiratoryFlow_type& x (*i.ForcedExpiratoryFlow ());
              if (typeid (PulmonaryFunctionTestData::ForcedExpiratoryFlow_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ForcedExpiratoryFlow",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "ForcedExpiratoryFlow",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // FunctionalResidualCapacity
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.FunctionalResidualCapacity ())
            {
              const PulmonaryFunctionTestData::FunctionalResidualCapacity_type& x (*i.FunctionalResidualCapacity ());
              if (typeid (PulmonaryFunctionTestData::FunctionalResidualCapacity_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "FunctionalResidualCapacity",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "FunctionalResidualCapacity",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // InspiratoryCapacity
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.InspiratoryCapacity ())
            {
              const PulmonaryFunctionTestData::InspiratoryCapacity_type& x (*i.InspiratoryCapacity ());
              if (typeid (PulmonaryFunctionTestData::InspiratoryCapacity_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "InspiratoryCapacity",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "InspiratoryCapacity",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // InspiratoryReserveVolume
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.InspiratoryReserveVolume ())
            {
              const PulmonaryFunctionTestData::InspiratoryReserveVolume_type& x (*i.InspiratoryReserveVolume ());
              if (typeid (PulmonaryFunctionTestData::InspiratoryReserveVolume_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "InspiratoryReserveVolume",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "InspiratoryReserveVolume",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // MaximumVoluntaryVentilation
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.MaximumVoluntaryVentilation ())
            {
              const PulmonaryFunctionTestData::MaximumVoluntaryVentilation_type& x (*i.MaximumVoluntaryVentilation ());
              if (typeid (PulmonaryFunctionTestData::MaximumVoluntaryVentilation_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "MaximumVoluntaryVentilation",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "MaximumVoluntaryVentilation",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // PeakExpiratoryFlow
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.PeakExpiratoryFlow ())
            {
              const PulmonaryFunctionTestData::PeakExpiratoryFlow_type& x (*i.PeakExpiratoryFlow ());
              if (typeid (PulmonaryFunctionTestData::PeakExpiratoryFlow_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "PeakExpiratoryFlow",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "PeakExpiratoryFlow",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // ResidualVolume
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.ResidualVolume ())
            {
              const PulmonaryFunctionTestData::ResidualVolume_type& x (*i.ResidualVolume ());
              if (typeid (PulmonaryFunctionTestData::ResidualVolume_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ResidualVolume",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "ResidualVolume",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // SlowVitalCapacity
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.SlowVitalCapacity ())
            {
              const PulmonaryFunctionTestData::SlowVitalCapacity_type& x (*i.SlowVitalCapacity ());
              if (typeid (PulmonaryFunctionTestData::SlowVitalCapacity_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "SlowVitalCapacity",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "SlowVitalCapacity",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // TotalLungCapacity
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.TotalLungCapacity ())
            {
              const PulmonaryFunctionTestData::TotalLungCapacity_type& x (*i.TotalLungCapacity ());
              if (typeid (PulmonaryFunctionTestData::TotalLungCapacity_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "TotalLungCapacity",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "TotalLungCapacity",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // VitalCapacity
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.VitalCapacity ())
            {
              const PulmonaryFunctionTestData::VitalCapacity_type& x (*i.VitalCapacity ());
              if (typeid (PulmonaryFunctionTestData::VitalCapacity_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "VitalCapacity",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "VitalCapacity",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // LungVolumePlot
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.LungVolumePlot ())
            {
              const PulmonaryFunctionTestData::LungVolumePlot_type& x (*i.LungVolumePlot ());
              if (typeid (PulmonaryFunctionTestData::LungVolumePlot_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "LungVolumePlot",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "LungVolumePlot",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PulmonaryFunctionTestData >
        _xsd_PulmonaryFunctionTestData_type_serializer_init (
          "PulmonaryFunctionTestData",
          "uri:/mil/tatrc/physiology/datamodel");
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

